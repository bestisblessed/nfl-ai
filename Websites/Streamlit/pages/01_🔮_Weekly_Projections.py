import streamlit as st
import pandas as pd
import numpy as np
import os
import glob
import json
import re
from utils.footer import render_footer
from utils.session_state import persistent_selectbox

PAGE_KEY_PREFIX = "weekly_projections"

BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

# Load game times from odds JSON files
@st.cache_data
def load_game_times():
    """Load game times from odds JSON files to sort games by start time"""
    games_with_times = {}
    try:
        data_dir = os.path.join(BASE_DIR, "data", "odds")
        json_files = sorted(
            [f for f in os.listdir(data_dir) if f.endswith(".json") and f.startswith('nfl')],
            reverse=True
        )
        if json_files:
            filepath = os.path.join(data_dir, json_files[0])
            with open(filepath) as f:
                data = json.load(f)
                for game in data:
                    game_time = game.get('Time', '')
                    day_and_matchup_key = list(game.keys())[1] if len(game.keys()) > 1 else None
                    if day_and_matchup_key:
                        teams = game[day_and_matchup_key].replace('\n', ' ').strip()
                        if '  ' in teams:
                            teams_list = [team.strip() for team in teams.split('  ') if team.strip()]
                        else:
                            teams_list = [team.strip() for team in re.split(r'\s+|,', teams) if team.strip()]
                        if len(teams_list) == 2:
                            matchup_key = f"{teams_list[0]} vs {teams_list[1]}"
                            games_with_times[matchup_key] = {
                                'time': game_time,
                                'date': day_and_matchup_key.strip()
                            }
    except Exception:
        pass
    return games_with_times


# Load games from Games.csv for a specific week
@st.cache_data
def load_games_for_week(week: int) -> pd.DataFrame:
    """Load games from Games.csv for a specific week in season 2025"""
    games_file = os.path.join(BASE_DIR, "data", "Games.csv")
    if os.path.exists(games_file):
        try:
            games_df = pd.read_csv(games_file)
            # Convert week to numeric in case it's stored as string
            games_df['week'] = pd.to_numeric(games_df['week'], errors='coerce')
            games_df['season'] = pd.to_numeric(games_df['season'], errors='coerce')
            # Filter by season 2025 and week
            week_games = games_df[
                (games_df['season'] == 2025) & 
                (games_df['week'] == week)
            ]
            if not week_games.empty:
                result = week_games[['home_team', 'away_team']].drop_duplicates()
                if not result.empty:
                    return result
            return pd.DataFrame()
        except Exception:
            return pd.DataFrame()
    return pd.DataFrame()


# Load upcoming games data for home/away determination
@st.cache_data
def load_upcoming_games():
    """Load upcoming games to determine home/away teams"""
    games_file = os.path.join(BASE_DIR, "upcoming_games.csv")
    if os.path.exists(games_file):
        games_df = pd.read_csv(games_file)
        # Create a mapping from matchup to home/away format
        games_mapping = {}
        for _, row in games_df.iterrows():
            # Store both team orders for lookup
            home, away = row['home_team'], row['away_team']
            games_mapping[(home, away)] = f"{away} @ {home}"
            games_mapping[(away, home)] = f"{away} @ {home}"
        return games_mapping, games_df
    return {}, pd.DataFrame()

# Page configuration
st.set_page_config(
    page_title="üîÆ NFL Game Projections",
    page_icon="üèà",
    layout="wide"
)

st.markdown(f"""
    <div style='text-align: center;'>
        <div style='font-size: 3.1rem; font-weight: 800; padding-bottom: 0.5rem;'>
            NFL Game Projections
        </div>
        <div style='color: #7f8c8d; font-size: 1rem; margin-top: 0; line-height: 1.2;'>
            Weekly Player Projections Generated by Machine Learning Algorithms
        </div>
    </div>
    """,
    unsafe_allow_html=True
)
st.divider()

# Simple, clean styling
st.markdown("""
<style>
    .data-section {
        background: white;
        padding: 1rem;
        border-radius: 8px;
        border: 1px solid #e1e8ed;
        margin: 1rem 0;
    }
    .section-title {
        font-size: 2rem;
        font-weight: 700;
        color: #2A3439;
        margin-bottom: 1rem;
        padding-bottom: 0.5rem;
        text-align: center;
        /* border-bottom: 2px solid #3498db; */
    }
</style>
""", unsafe_allow_html=True)
# st.write("")

# Function to load projections data
@st.cache_data
def load_projections_data():
    """Load and process projections data from CSV files"""
    projections_dir = os.path.join(BASE_DIR, "data/projections")

    # Find all projection files
    projection_files = glob.glob(os.path.join(projections_dir, "week*_all_props_summary.csv"))

    if not projection_files:
        st.error(f"No projection files found in {projections_dir}")
        return None, []

    # Extract available weeks
    available_weeks = []
    for file in projection_files:
        week_num = file.split('week')[1].split('_')[0]
        available_weeks.append(int(week_num))

    available_weeks.sort()

    return projection_files, available_weeks

# Function to get projections for a specific week
@st.cache_data
def get_week_projections(week_num):
    """Get projections data for a specific week"""
    file_path = os.path.join(BASE_DIR, f"data/projections/week{week_num}_all_props_summary.csv")

    if not os.path.exists(file_path):
        return None

    try:
        df = pd.read_csv(file_path)

        # Clean and process the data
        df = df.dropna(subset=['pred_yards'])
        df['pred_yards'] = pd.to_numeric(df['pred_yards'], errors='coerce')
        df = df.dropna(subset=['pred_yards'])

        # Add trend (placeholder - could be enhanced with historical data)
        trends = np.random.choice(['‚ÜóÔ∏è', '‚Üí', '‚ÜòÔ∏è'], size=len(df), p=[0.3, 0.4, 0.3])
        df['trend'] = trends

        return df
    except Exception as e:
        st.error(f"Error loading week {week_num} data: {str(e)}")
        return None

# Load available data
projection_files, available_weeks = load_projections_data()

if not available_weeks:
    st.error("No projection data available. Please ensure projection files are in data/projections/")
    st.stop()

st.sidebar.markdown("<h2 style='text-align: center;'>Selection</h2>", unsafe_allow_html=True)
week_options = [f"Week {week}" for week in available_weeks]
selected_week_display = persistent_selectbox(
    "Week:",
    options=week_options,
    page=PAGE_KEY_PREFIX,
    widget="week",
    default=week_options[-1] if week_options else None,
    container=st.sidebar,
)

# Get the selected week number
selected_week = selected_week_display.replace("Week ", "")

# Load data for selected week
projections_df = get_week_projections(int(selected_week))

if projections_df is None:
    st.error(f"No data available for {selected_week_display}")
    st.stop()

# Load games mapping for correct home/away designation
games_mapping, upcoming_games_df = load_upcoming_games()
game_times = load_game_times()

# Try to get games from Games.csv first (for historical weeks)
week_games_df = load_games_for_week(int(selected_week))

# Create matchup options - prioritize Games.csv, then upcoming_games.csv, then projections data
if not week_games_df.empty and "home_team" in week_games_df.columns and "away_team" in week_games_df.columns:
    # Use Games.csv to get correct home/away designation
    matchups = [
        f"{row['away_team']} @ {row['home_team']}"
        for _, row in week_games_df.iterrows()
    ]
    matchups = sorted(matchups)
elif not upcoming_games_df.empty:
    # Fallback: use upcoming_games.csv with time info for sorting
    games_list = []
    for _, row in upcoming_games_df.iterrows():
        away, home = row['away_team'], row['home_team']
        matchup_str = f"{away} @ {home}"
        
        # Try to find time from odds data
        time_info = None
        for key, value in game_times.items():
            teams_in_key = [t.strip() for t in re.split(r'\s+vs\s+', key, flags=re.IGNORECASE)]
            if len(teams_in_key) == 2:
                time_info = value
                break
        
        games_list.append({
            'matchup': matchup_str,
            'time': time_info['time'] if time_info else '',
            'date': time_info['date'] if time_info else '',
            'sort_key': (time_info['date'] if time_info else '', time_info['time'] if time_info else '')
        })
    
    # Sort by date and time
    games_list.sort(key=lambda x: x['sort_key'])
    matchups = [g['matchup'] for g in games_list]
else:
    # Final fallback: create matchups from projections data
    matchups = []
    matchup_set = set()
    for _, row in projections_df.iterrows():
        team1, team2 = row['team'], row['opp']
        matchup = games_mapping.get((team1, team2))
        if matchup is None:
            matchup = games_mapping.get((team2, team1))
        if matchup is None:
            team1_sorted, team2_sorted = sorted([team1, team2])
            matchup = f"{team1_sorted} @ {team2_sorted}"
        if matchup not in matchup_set:
            matchup_set.add(matchup)
            matchups.append(matchup)
    matchups = sorted(matchups)

selected_matchup = persistent_selectbox(
    "Game:",
    options=matchups,
    page=PAGE_KEY_PREFIX,
    widget="matchup",
    default=matchups[0] if matchups else None,
    container=st.sidebar,
)
st.sidebar.write("")
st.sidebar.write("")

# Add download button to sidebar after week selection
with st.sidebar:
    st.markdown(
        "<div style='font-size: 1.2rem; font-weight: 600; margin-bottom: 12px; text-align: center;'>Export</div>"
        "<div style='height: 5px;'></div>",
        unsafe_allow_html=True
    )
    html_filename = f"week{selected_week}_complete_props_report.html"
    html_path = os.path.join(BASE_DIR, "data/projections", html_filename)

    if os.path.exists(html_path):
        with open(html_path, "rb") as html_file:
            st.download_button(
                label="Download HTML",
                data=html_file.read(),
                file_name=html_filename,
                mime="text/html",
                use_container_width=True
            )
    else:
        st.info("HTML report not available for this week")


# Apply matchup filter
if selected_matchup:
    team1, team2 = selected_matchup.split(" @ ")
    filtered_df = projections_df[
        ((projections_df['team'] == team1) & (projections_df['opp'] == team2)) |
        ((projections_df['team'] == team2) & (projections_df['opp'] == team1))
    ].copy()
else:
    filtered_df = projections_df.copy()

# Main data display
st.markdown(f"""
    <div style='background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        padding: 1px;
                        border-radius: 15px;
                        margin: 10px 0 25px 0;
                        text-align: center;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);'>
        <h2 style='color: white; margin: 0; font-size: 2em; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);'>
            {selected_matchup} Projections
        </h2>
    </div>
    """,
    unsafe_allow_html=True
)
st.write("")

if filtered_df.empty:
    st.info("No data matches your filters. Try adjusting your selections.")
else:
    # Define the position-prop combinations we want to show
    position_prop_combinations = [
        ('QB', 'Passing Yards'),
        ('QB', 'Rushing Yards'),
        ('RB', 'Rushing Yards'),
        ('RB', 'Receiving Yards'),
        ('WR', 'Receiving Yards'),
        ('TE', 'Receiving Yards')
    ]

    # QB sections - side by side
    qb_cols = st.columns(2)

    # QB Passing Yards
    with qb_cols[0]:
        qb_passing_data = filtered_df[
            (filtered_df['position'] == 'QB') &
            (filtered_df['prop_type'] == 'Passing Yards')
        ].copy()

        if not qb_passing_data.empty:
            st.markdown('<h4 style="text-align: center; font-size: 1.1em; margin-bottom: 0.5em;">QB Passing Yards</h4>', unsafe_allow_html=True)
            display_df = qb_passing_data.sort_values('pred_yards', ascending=False)

            # st.markdown('<div class="data-section">', unsafe_allow_html=True)
            st.dataframe(
                display_df[['full_name', 'team', 'pred_yards']].rename(columns={
                    'full_name': 'Player',
                    'team': 'Team',
                    'pred_yards': 'Projected Yards'
                }),
                use_container_width=True,
                hide_index=True
            )
            st.markdown('</div>', unsafe_allow_html=True)

    # QB Rushing Yards
    with qb_cols[1]:
        qb_rushing_data = filtered_df[
            (filtered_df['position'] == 'QB') &
            (filtered_df['prop_type'] == 'Rushing Yards')
        ].copy()

        if not qb_rushing_data.empty:
            st.markdown('<h4 style="text-align: center; font-size: 1.1em; margin-bottom: 0.5em;">QB Rushing Yards</h4>', unsafe_allow_html=True)
            display_df = qb_rushing_data.sort_values('pred_yards', ascending=False)

            # st.markdown('<div class="data-section">', unsafe_allow_html=True)
            st.dataframe(
                display_df[['full_name', 'team', 'pred_yards']].rename(columns={
                    'full_name': 'Player',
                    'team': 'Team',
                    'pred_yards': 'Projected Yards'
                }),
                use_container_width=True,
                hide_index=True
            )
            st.markdown('</div>', unsafe_allow_html=True)

    # RB sections - side by side
    rb_cols = st.columns(2)

    # RB Rushing Yards
    with rb_cols[0]:
        rb_rushing_data = filtered_df[
            (filtered_df['position'] == 'RB') &
            (filtered_df['prop_type'] == 'Rushing Yards')
        ].copy()

        if not rb_rushing_data.empty:
            st.markdown('<h4 style="text-align: center; font-size: 1.1em; margin-bottom: 0.5em;">RB Rushing Yards</h4>', unsafe_allow_html=True)
            display_df = rb_rushing_data.sort_values('pred_yards', ascending=False)

            # st.markdown('<div class="data-section">', unsafe_allow_html=True)
            st.dataframe(
                display_df[['full_name', 'team', 'pred_yards']].rename(columns={
                    'full_name': 'Player',
                    'team': 'Team',
                    'pred_yards': 'Projected Yards'
                }),
                use_container_width=True,
                hide_index=True
            )
            st.markdown('</div>', unsafe_allow_html=True)

    # RB Receiving Yards
    with rb_cols[1]:
        rb_receiving_data = filtered_df[
            (filtered_df['position'] == 'RB') &
            (filtered_df['prop_type'] == 'Receiving Yards')
        ].copy()

        if not rb_receiving_data.empty:
            st.markdown('<h4 style="text-align: center; font-size: 1.1em; margin-bottom: 0.5em;">RB Receiving Yards</h4>', unsafe_allow_html=True)
            display_df = rb_receiving_data.sort_values('pred_yards', ascending=False)

            # st.markdown('<div class="data-section">', unsafe_allow_html=True)
            st.dataframe(
                display_df[['full_name', 'team', 'pred_yards']].rename(columns={
                    'full_name': 'Player',
                    'team': 'Team',
                    'pred_yards': 'Projected Yards'
                }),
                use_container_width=True,
                hide_index=True
            )
            st.markdown('</div>', unsafe_allow_html=True)

    # WR and TE Receiving Yards (side by side)
    wr_te_cols = st.columns(2)

    # WR Receiving Yards
    with wr_te_cols[0]:
        wr_receiving_data = filtered_df[
            (filtered_df['position'] == 'WR') &
            (filtered_df['prop_type'] == 'Receiving Yards')
        ].copy()

        if not wr_receiving_data.empty:
            st.markdown('<h4 style="text-align: center; font-size: 1.1em; margin-bottom: 0.5em;">WR Receiving Yards</h4>', unsafe_allow_html=True)
            display_df = wr_receiving_data.sort_values('pred_yards', ascending=False)

            # st.markdown('<div class="data-section">', unsafe_allow_html=True)
            st.dataframe(
                display_df[['full_name', 'team', 'pred_yards']].rename(columns={
                    'full_name': 'Player',
                    'team': 'Team',
                    'pred_yards': 'Projected Yards'
                }),
                use_container_width=True,
                hide_index=True
            )
            # st.markdown('</div>', unsafe_allow_html=True)

    # TE Receiving Yards
    with wr_te_cols[1]:
        te_receiving_data = filtered_df[
            (filtered_df['position'] == 'TE') &
            (filtered_df['prop_type'] == 'Receiving Yards')
        ].copy()

        if not te_receiving_data.empty:
            st.markdown('<h4 style="text-align: center; font-size: 1.1em; margin-bottom: 0.5em;">TE Receiving Yards</h4>', unsafe_allow_html=True)
            display_df = te_receiving_data.sort_values('pred_yards', ascending=False)

            # st.markdown('<div class="data-section">', unsafe_allow_html=True)
            st.dataframe(
                display_df[['full_name', 'team', 'pred_yards']].rename(columns={
                    'full_name': 'Player',
                    'team': 'Team',
                    'pred_yards': 'Projected Yards'
                }),
                use_container_width=True,
                hide_index=True
            )
            # st.markdown('</div>', unsafe_allow_html=True)

# Add download button at bottom of page
st.write("")
st.write("")
col1, col2, col3 = st.columns([1, 1, 1])
with col2:
    # HTML report download button at bottom
    html_filename = f"week{selected_week}_complete_props_report.html"
    html_path = os.path.join(BASE_DIR, "data/projections", html_filename)

    if os.path.exists(html_path):
        with open(html_path, "rb") as html_file:
            html_data = html_file.read()
        st.download_button(
            label="üìÑ Download Report",
            data=html_data,
            file_name=html_filename,
            mime="text/html",
            help=f"Download the {selected_week_display} complete props HTML report",
            use_container_width=True
        )
    else:
        st.info("HTML report not available for this week")

# Footer
render_footer()
